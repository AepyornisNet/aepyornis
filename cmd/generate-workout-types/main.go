package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type WorkoutTypeConfig struct {
	Name       string `yaml:"name"`
	Location   bool   `yaml:"location"`
	Distance   bool   `yaml:"distance"`
	Repetition bool   `yaml:"repetition"`
	Weight     bool   `yaml:"weight"`
}

type Config struct {
	WorkoutTypes []WorkoutTypeConfig `yaml:"workout_types"`
}

const goTemplate = `// Code generated by generate-workout-types; DO NOT EDIT.
package database

import (
	"maps"
	"slices"
)

type (
	WorkoutType string
)

const (
	WorkoutTypeUnknown       WorkoutType = "unknown"
	WorkoutTypeAutoDetect    WorkoutType = "auto"
{{- range .WorkoutTypes }}
	WorkoutType{{ .ConstName }} WorkoutType = "{{ .Name }}"
{{- end }}

	WorkoutTypeClassLocation   = "location"
	WorkoutTypeClassDistance   = "distance"
	WorkoutTypeClassRepetition = "repetition"
	WorkoutTypeClassWeight     = "weight"
	WorkoutTypeClassDuration   = "duration"
)

type WorkoutTypeConfiguration struct {
	Location   bool
	Distance   bool
	Repetition bool
	Weight     bool
}

var workoutTypeConfigs = map[WorkoutType]WorkoutTypeConfiguration{
{{- range .WorkoutTypes }}
	WorkoutType{{ .ConstName }}: {Location: {{ .Location }}, Distance: {{ .Distance }}, Repetition: {{ .Repetition }}, Weight: {{ .Weight }}},
{{- end }}
}

var (
	workoutTypes        []WorkoutType
	workoutTypesByClass map[string][]WorkoutType
)

func WorkoutTypes() []WorkoutType {
	if len(workoutTypes) > 0 {
		return workoutTypes
	}

	workoutTypes = slices.Collect(maps.Keys(workoutTypeConfigs))

	slices.Sort(workoutTypes)

	return workoutTypes
}

func getOrSetByClass(class string, fn func(c WorkoutTypeConfiguration) bool) []WorkoutType {
	if workoutTypesByClass == nil {
		workoutTypesByClass = make(map[string][]WorkoutType)
	}

	if wt, ok := workoutTypesByClass[class]; ok {
		return wt
	}

	keys := []WorkoutType{}

	for k, c := range workoutTypeConfigs {
		if !fn(c) {
			continue
		}

		keys = append(keys, k)
	}

	slices.Sort(keys)
	workoutTypesByClass[WorkoutTypeClassDistance] = keys

	return keys
}

func DistanceWorkoutTypes() []WorkoutType {
	return getOrSetByClass(WorkoutTypeClassDistance, func(c WorkoutTypeConfiguration) bool {
		return c.Distance
	})
}

func WeightWorkoutTypes() []WorkoutType {
	return getOrSetByClass(WorkoutTypeClassWeight, func(c WorkoutTypeConfiguration) bool {
		return c.Weight
	})
}

func RepetitionWorkoutTypes() []WorkoutType {
	return getOrSetByClass(WorkoutTypeClassRepetition, func(c WorkoutTypeConfiguration) bool {
		return c.Repetition
	})
}

func LocationWorkoutTypes() []WorkoutType {
	return getOrSetByClass(WorkoutTypeClassLocation, func(c WorkoutTypeConfiguration) bool {
		return c.Location
	})
}

func DurationWorkoutTypes() []WorkoutType {
	return getOrSetByClass(WorkoutTypeClassDuration, func(c WorkoutTypeConfiguration) bool {
		return true // All workout types store duration
	})
}

func (wt WorkoutType) StringT() string {
	return "sports." + wt.String()
}

func (wt WorkoutType) String() string {
	if wt == "" {
		return string(WorkoutTypeUnknown)
	}

	return string(wt)
}

func (wt WorkoutType) IsDistance() bool {
	return workoutTypeConfigs[wt].Distance
}

func (wt WorkoutType) IsRepetition() bool {
	return workoutTypeConfigs[wt].Repetition
}

func (wt WorkoutType) IsDuration() bool {
	_, ok := workoutTypeConfigs[wt]
	return ok
}

func (wt WorkoutType) IsWeight() bool {
	return workoutTypeConfigs[wt].Weight
}

func (wt WorkoutType) IsLocation() bool {
	return workoutTypeConfigs[wt].Location
}

func AsWorkoutType(s string) WorkoutType {
	return WorkoutType(s)
}
`

type TemplateData struct {
	WorkoutTypes []struct {
		Name       string
		ConstName  string
		Location   bool
		Distance   bool
		Repetition bool
		Weight     bool
	}
}

func toPascalCase(s string) string {
	// Special cases for known constants
	switch s {
	case "push-ups":
		return "Pushups"
	case "e-cycling":
		return "ECycling"
	case "weight-lifting":
		return "WeightLifting"
	case "horse-riding":
		return "HorseRiding"
	case "inline-skating":
		return "InlineSkating"
	}

	parts := strings.Split(s, "-")
	for i, part := range parts {
		parts[i] = strings.Title(part)
	}
	return strings.Join(parts, "")
}

func main() {
	// Read the YAML config file
	configPath := filepath.Join("..", "..", "workout-types.yaml")
	data, err := os.ReadFile(configPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading config file: %v\n", err)
		os.Exit(1)
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing YAML: %v\n", err)
		os.Exit(1)
	}

	// Prepare template data
	templateData := TemplateData{}
	for _, wt := range config.WorkoutTypes {
		templateData.WorkoutTypes = append(templateData.WorkoutTypes, struct {
			Name       string
			ConstName  string
			Location   bool
			Distance   bool
			Repetition bool
			Weight     bool
		}{
			Name:       wt.Name,
			ConstName:  toPascalCase(wt.Name),
			Location:   wt.Location,
			Distance:   wt.Distance,
			Repetition: wt.Repetition,
			Weight:     wt.Weight,
		})
	}

	// Generate the Go code
	tmpl, err := template.New("workout_types").Parse(goTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	outputPath := filepath.Join("..", "..", "pkg", "database", "workout_type.go")
	f, err := os.Create(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	if err := tmpl.Execute(f, templateData); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Generated workout_type.go successfully")
}
