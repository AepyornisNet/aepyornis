package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type WorkoutTypeConfig struct {
	Name            string               `yaml:"name"`
	Location        bool                 `yaml:"location"`
	Distance        bool                 `yaml:"distance"`
	Repetition      bool                 `yaml:"repetition"`
	Weight          bool                 `yaml:"weight"`
	DistanceTargets []DistanceTargetYAML `yaml:"distance_targets"`
}

type DistanceTargetYAML struct {
	Label    string  `yaml:"label"`
	Distance float64 `yaml:"distance"`
}

type Config struct {
	WorkoutTypes []WorkoutTypeConfig `yaml:"workout_types"`
}

const goTemplate = `// Code generated by generate-workout-types; DO NOT EDIT.
package model

const (
{{- range .WorkoutTypes }}
	WorkoutType{{ .ConstName }} WorkoutType = "{{ .Name }}"
{{- end }}
)

var workoutTypeConfigs = map[WorkoutType]WorkoutTypeConfiguration{
{{- range .WorkoutTypes }}
	WorkoutType{{ .ConstName }}: {Location: {{ .Location }}, Distance: {{ .Distance }}, Repetition: {{ .Repetition }}, Weight: {{ .Weight }}},
{{- end }}
}
`

type TemplateData struct {
	WorkoutTypes []struct {
		Name       string
		ConstName  string
		Location   bool
		Distance   bool
		Repetition bool
		Weight     bool
	}
	DistanceTargets []DistanceTargetSpec
}

type DistanceTargetSpec struct {
	ConstName string
	Items     []DistanceTargetItem
}

type DistanceTargetItem struct {
	Label    string
	Distance float64
}

func toPascalCase(s string) string {
	// Special cases for known constants
	switch s {
	case "push-ups":
		return "Pushups"
	case "e-cycling":
		return "ECycling"
	case "weight-lifting":
		return "WeightLifting"
	case "horse-riding":
		return "HorseRiding"
	case "inline-skating":
		return "InlineSkating"
	}

	parts := strings.Split(s, "-")
	for i, part := range parts {
		parts[i] = strings.Title(part)
	}
	return strings.Join(parts, "")
}

const recordsTargetsTemplate = `// Code generated by generate-workout-types; DO NOT EDIT.
package model

// DistanceRecordTarget defines a target distance label and its size in meters.
type DistanceRecordTarget struct {
	Label          string
	TargetDistance float64
}

var defaultDistanceRecordTargets = map[WorkoutType][]DistanceRecordTarget{
{{- range .DistanceTargets }}
	WorkoutType{{ .ConstName }}: {
{{- range .Items }}
		{Label: "{{ .Label }}", TargetDistance: {{ printf "%.4f" .Distance }}},
{{- end }}
	},
{{- end }}
}

func distanceRecordTargetsFor(wt WorkoutType) []DistanceRecordTarget {
	targets, ok := defaultDistanceRecordTargets[wt]
	if !ok {
		return nil
	}

	return targets
}
`

func main() {
	// Read the YAML config file
	configPath := filepath.Join("..", "..", "workout-types.yaml")
	data, err := os.ReadFile(configPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading config file: %v\n", err)
		os.Exit(1)
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing YAML: %v\n", err)
		os.Exit(1)
	}

	// Prepare template data
	templateData := TemplateData{}

	for _, wt := range config.WorkoutTypes {
		pascal := toPascalCase(wt.Name)

		templateData.WorkoutTypes = append(templateData.WorkoutTypes, struct {
			Name       string
			ConstName  string
			Location   bool
			Distance   bool
			Repetition bool
			Weight     bool
		}{
			Name:       wt.Name,
			ConstName:  pascal,
			Location:   wt.Location,
			Distance:   wt.Distance,
			Repetition: wt.Repetition,
			Weight:     wt.Weight,
		})

		if len(wt.DistanceTargets) > 0 {
			spec := DistanceTargetSpec{ConstName: pascal}
			for _, it := range wt.DistanceTargets {
				spec.Items = append(spec.Items, DistanceTargetItem{Label: it.Label, Distance: it.Distance})
			}
			templateData.DistanceTargets = append(templateData.DistanceTargets, spec)
		}
	}

	// Generate the Go code
	tmpl, err := template.New("workout_types").Parse(goTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	outputPath := filepath.Join("..", "..", "pkg", "model", "workout_type.go")
	f, err := os.Create(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}

	if err := tmpl.Execute(f, templateData); err != nil {
		f.Close()
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	} else {
		f.Close()
	}

	fmt.Println("Generated workout_type.go successfully")

	// Generate distance record targets file
	recordsTmpl, err := template.New("records_targets").Parse(recordsTargetsTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing records targets template: %v\n", err)
		os.Exit(1)
	}

	recordsPath := filepath.Join("..", "..", "pkg", "model", "records_targets.go")
	recordsFile, err := os.Create(recordsPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating records_targets.go: %v\n", err)
		os.Exit(1)
	}

	if err := recordsTmpl.Execute(recordsFile, templateData); err != nil {
		recordsFile.Close()
		fmt.Fprintf(os.Stderr, "Error executing records targets template: %v\n", err)
		os.Exit(1)
	} else {
		recordsFile.Close()
	}

	fmt.Println("Generated records_targets.go successfully")
}
